/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else if(typeof exports === 'object')
		exports["ThreeCSG"] = factory(require("THREE"));
	else
		root["ThreeCSG"] = factory(root["THREE"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE_three__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/csg-lib.ts":
/*!************************!*\
  !*** ./src/csg-lib.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CSG\": () => (/* binding */ CSG),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex),\n/* harmony export */   \"Vector\": () => (/* binding */ Vector),\n/* harmony export */   \"Polygon\": () => (/* binding */ Polygon),\n/* harmony export */   \"Plane\": () => (/* binding */ Plane)\n/* harmony export */ });\n/**\r\n * @copyright   Copyright (c) 2011 Evan Wallace (http://madebyevan.com/)\r\n * @license     {@link https://github.com/evanw/csg.js/blob/master/LICENSE|MIT}\r\n * @description THREE.js rework by thrax\r\n */\r\n// # class CSG\r\n// Holds a binary space partition tree representing a 3D solid. Two solids can\r\n// be combined using the `union()`, `subtract()`, and `intersect()` methods.\r\nclass CSG {\r\n    constructor() {\r\n        this.polygons = [];\r\n    }\r\n    clone() {\r\n        let csg = new CSG();\r\n        csg.polygons = this.polygons.map(function (p) {\r\n            return p.clone();\r\n        });\r\n        return csg;\r\n    }\r\n    toPolygons() {\r\n        return this.polygons;\r\n    }\r\n    union(csg) {\r\n        let a = new Node(this.clone().polygons);\r\n        let b = new Node(csg.clone().polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    subtract(csg) {\r\n        let a = new Node(this.clone().polygons);\r\n        let b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    intersect(csg) {\r\n        let a = new Node(this.clone().polygons);\r\n        let b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    // Return a new CSG solid with solid and empty space switched. This solid is\r\n    // not modified.\r\n    inverse() {\r\n        let csg = this.clone();\r\n        csg.polygons.forEach(p => p.flip());\r\n        return csg;\r\n    }\r\n    static fromJSON(json) {\r\n        return CSG.fromPolygons(json.polygons.map(p => new Polygon(\r\n        // @ts-ignore\r\n        p.vertices.map(v => new Vertex(v.pos, v.normal, v.uv)), p.shared)));\r\n    }\r\n    // Construct a CSG solid from a list of `Polygon` instances.\r\n    static fromPolygons(polygons) {\r\n        let csg = new CSG();\r\n        csg.polygons = polygons;\r\n        return csg;\r\n    }\r\n}\r\n// # class Vector\r\n// Represents a 3D vector.\r\n//\r\n// Example usage:\r\n//\r\n//     new CSG.Vector(1, 2, 3);\r\nclass Vector {\r\n    constructor(x = 0, y = 0, z = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    }\r\n    clone() {\r\n        return new Vector(this.x, this.y, this.z);\r\n    }\r\n    negate() {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n    add(a) {\r\n        this.x += a.x;\r\n        this.y += a.y;\r\n        this.z += a.z;\r\n        return this;\r\n    }\r\n    sub(a) {\r\n        this.x -= a.x;\r\n        this.y -= a.y;\r\n        this.z -= a.z;\r\n        return this;\r\n    }\r\n    times(a) {\r\n        this.x *= a;\r\n        this.y *= a;\r\n        this.z *= a;\r\n        return this;\r\n    }\r\n    dividedBy(a) {\r\n        this.x /= a;\r\n        this.y /= a;\r\n        this.z /= a;\r\n        return this;\r\n    }\r\n    lerp(a, t) {\r\n        return this.add(tv0.copy(a).sub(this).times(t));\r\n    }\r\n    unit() {\r\n        return this.dividedBy(this.length());\r\n    }\r\n    length() {\r\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\r\n    }\r\n    normalize() {\r\n        return this.unit();\r\n    }\r\n    cross(b) {\r\n        let a = this;\r\n        const ax = a.x, ay = a.y, az = a.z;\r\n        const bx = b.x, by = b.y, bz = b.z;\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n        return this;\r\n    }\r\n    dot(b) {\r\n        return this.x * b.x + this.y * b.y + this.z * b.z;\r\n    }\r\n}\r\n//Temporaries used to avoid internal allocation..\r\nlet tv0 = new Vector();\r\nlet tv1 = new Vector();\r\n// # class Vertex\r\n// Represents a vertex of a polygon. Use your own vertex class instead of this\r\n// one to provide additional features like texture coordinates and vertex\r\n// colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n// `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n// defined by `CSG.Vertex`. This class provides `normal` so convenience\r\n// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n// is not used anywhere else.\r\nclass Vertex {\r\n    constructor(pos, normal, uv, color) {\r\n        this.pos = new Vector().copy(pos);\r\n        this.normal = new Vector().copy(normal);\r\n        this.uv = new Vector().copy(uv);\r\n        this.uv.z = 0;\r\n        color && (this.color = new Vector().copy(color));\r\n    }\r\n    clone() {\r\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\r\n    }\r\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n    // orientation of a polygon is flipped.\r\n    flip() {\r\n        this.normal.negate();\r\n    }\r\n    // Create a new vertex between this vertex and `other` by linearly\r\n    // interpolating all properties using a parameter of `t`. Subclasses should\r\n    // override this to interpolate additional properties.\r\n    interpolate(other, t) {\r\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\r\n    }\r\n}\r\n// # class Plane\r\n// Represents a plane in 3D space.\r\nclass Plane {\r\n    constructor(normal, w) {\r\n        this.normal = normal;\r\n        this.w = w;\r\n    }\r\n    // `Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n    // point is on the plane.\r\n    static get EPSILON() {\r\n        return 1e-5;\r\n    }\r\n    clone() {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n    flip() {\r\n        this.normal.negate();\r\n        this.w = -this.w;\r\n    }\r\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\r\n    // fragments in the appropriate lists. Coplanar polygons go into either\r\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\r\n    // respect to this plane. Polygons in front or in back of this plane go into\r\n    // either `front` or `back`.\r\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        let types = [];\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            let t = this.normal.dot(polygon.vertices[i].pos) - this.w;\r\n            let type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n        // Put the polygon in the correct list, splitting it when necessary.\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                ;\r\n                (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING:\r\n                let f = [];\r\n                let b = [];\r\n                for (let i = 0; i < polygon.vertices.length; i++) {\r\n                    let j = (i + 1) % polygon.vertices.length;\r\n                    let ti = types[i], tj = types[j];\r\n                    let vi = polygon.vertices[i], vj = polygon.vertices[j];\r\n                    if (ti != BACK)\r\n                        f.push(vi);\r\n                    if (ti != FRONT)\r\n                        b.push(ti != BACK ? vi.clone() : vi);\r\n                    if ((ti | tj) == SPANNING) {\r\n                        let t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(tv0.copy(vj.pos).sub(vi.pos));\r\n                        let v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                if (f.length >= 3)\r\n                    front.push(new Polygon(f, polygon.shared));\r\n                if (b.length >= 3)\r\n                    back.push(new Polygon(b, polygon.shared));\r\n                break;\r\n        }\r\n    }\r\n    static fromPoints(a, b, c) {\r\n        let n = tv0.copy(b).sub(a).cross(tv1.copy(c).sub(a)).normalize();\r\n        return new Plane(n.clone(), n.dot(a));\r\n    }\r\n}\r\n// # class Polygon\r\n// Represents a convex polygon. The vertices used to initialize a polygon must\r\n// be coplanar and form a convex loop. They do not have to be `Vertex`\r\n// instances but they must behave similarly (duck typing can be used for\r\n// customization).\r\n//\r\n// Each convex polygon has a `shared` property, which is shared between all\r\n// polygons that are clones of each other or were split from the same polygon.\r\n// This can be used to define per-polygon properties (such as surface color).\r\nclass Polygon {\r\n    constructor(vertices, shared) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n    clone() {\r\n        return new Polygon(this.vertices.map(v => v.clone()), this.shared);\r\n    }\r\n    flip() {\r\n        this.vertices.reverse().map(v => v.flip());\r\n        this.plane.flip();\r\n    }\r\n}\r\n// # class Node\r\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n// by picking a polygon to split along. That polygon (and all other coplanar\r\n// polygons) are added directly to that node and the other polygons are added to\r\n// the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n// no distinction between internal and leaf nodes.\r\nclass Node {\r\n    constructor(polygons) {\r\n        this.plane = null;\r\n        this.front = null;\r\n        this.back = null;\r\n        this.polygons = [];\r\n        if (polygons)\r\n            this.build(polygons);\r\n    }\r\n    clone() {\r\n        let node = new Node();\r\n        node.plane = this.plane && this.plane.clone();\r\n        node.front = this.front && this.front.clone();\r\n        node.back = this.back && this.back.clone();\r\n        node.polygons = this.polygons.map(p => p.clone());\r\n        return node;\r\n    }\r\n    // Convert solid space to empty space and empty space to solid space.\r\n    invert() {\r\n        for (let i = 0; i < this.polygons.length; i++)\r\n            this.polygons[i].flip();\r\n        this.plane && this.plane.flip();\r\n        this.front && this.front.invert();\r\n        this.back && this.back.invert();\r\n        let temp = this.front;\r\n        this.front = this.back;\r\n        this.back = temp;\r\n    }\r\n    // Recursively remove all polygons in `polygons` that are inside this BSP\r\n    // tree.\r\n    clipPolygons(polygons) {\r\n        if (!this.plane)\r\n            return polygons.slice();\r\n        let front = [], back = [];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this.front)\r\n            front = this.front.clipPolygons(front);\r\n        if (this.back)\r\n            back = this.back.clipPolygons(back);\r\n        else\r\n            back = [];\r\n        return front.concat(back);\r\n    }\r\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\r\n    // `bsp`.\r\n    clipTo(bsp) {\r\n        this.polygons = bsp.clipPolygons(this.polygons);\r\n        if (this.front)\r\n            this.front.clipTo(bsp);\r\n        if (this.back)\r\n            this.back.clipTo(bsp);\r\n    }\r\n    // Return a list of all polygons in this BSP tree.\r\n    allPolygons() {\r\n        let polygons = this.polygons.slice();\r\n        if (this.front)\r\n            polygons = polygons.concat(this.front.allPolygons());\r\n        if (this.back)\r\n            polygons = polygons.concat(this.back.allPolygons());\r\n        return polygons;\r\n    }\r\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n    // new polygons are filtered down to the bottom of the tree and become new\r\n    // nodes there. Each set of polygons is partitioned using the first polygon\r\n    // (no heuristic is used to pick a good split).\r\n    build(polygons) {\r\n        if (!polygons.length)\r\n            return;\r\n        if (!this.plane)\r\n            this.plane = polygons[0].plane.clone();\r\n        let front = [], back = [];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this.front)\r\n                this.front = new Node();\r\n            this.front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this.back)\r\n                this.back = new Node();\r\n            this.back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n// Return a new CSG solid representing space in either this solid or in the\r\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n//\r\n//     A.union(B)\r\n//\r\n//     +-------+            +-------+\r\n//     |       |            |       |\r\n//     |   A   |            |       |\r\n//     |    +--+----+   =   |       +----+\r\n//     +----+--+    |       +----+       |\r\n//          |   B   |            |       |\r\n//          |       |            |       |\r\n//          +-------+            +-------+\r\n//\r\n// Return a new CSG solid representing space in this solid but not in the\r\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n//\r\n//     A.subtract(B)\r\n//\r\n//     +-------+            +-------+\r\n//     |       |            |       |\r\n//     |   A   |            |       |\r\n//     |    +--+----+   =   |    +--+\r\n//     +----+--+    |       +----+\r\n//          |   B   |\r\n//          |       |\r\n//          +-------+\r\n//\r\n// Return a new CSG solid representing space both this solid and in the\r\n// solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n//\r\n//     A.intersect(B)\r\n//\r\n//     +-------+\r\n//     |       |\r\n//     |   A   |\r\n//     |    +--+----+   =   +--+\r\n//     +----+--+    |       +--+\r\n//          |   B   |\r\n//          |       |\r\n//          +-------+\r\n//\r\n\n\n//# sourceURL=webpack://ThreeCSG/./src/csg-lib.ts?");

/***/ }),

/***/ "./src/three-csg.ts":
/*!**************************!*\
  !*** ./src/three-csg.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThreeCSG\": () => (/* binding */ ThreeCSG)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _csg_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csg-lib */ \"./src/csg-lib.ts\");\n/**\r\n * @copyright   Copyright (c) 2021 Michael Schlachter (https://github.com/manthrax)\r\n * @license     {@link https://github.com/manthrax/THREE-CSGMesh/blob/master/LICENSE|MIT}\r\n */\r\n\r\n\r\nlet ttvv0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\r\nlet tmpm3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\nlet nbuf3 = ct => {\r\n    return {\r\n        top: 0,\r\n        array: new Float32Array(ct),\r\n        write: function (v) {\r\n            this.array[this.top++] = v.x;\r\n            this.array[this.top++] = v.y;\r\n            this.array[this.top++] = v.z;\r\n        }\r\n    };\r\n};\r\nlet nbuf2 = ct => {\r\n    return {\r\n        top: 0,\r\n        array: new Float32Array(ct),\r\n        write: function (v) {\r\n            this.array[this.top++] = v.x;\r\n            this.array[this.top++] = v.y;\r\n        }\r\n    };\r\n};\r\nclass ThreeCSG extends _csg_lib__WEBPACK_IMPORTED_MODULE_1__.CSG {\r\n    fromGeometry(geom, objectIndex) {\r\n        let polys = [];\r\n        if (geom.isGeometry) {\r\n            let fs = geom.faces;\r\n            let vs = geom.vertices;\r\n            let fm = ['a', 'b', 'c'];\r\n            for (let i = 0; i < fs.length; i++) {\r\n                let f = fs[i];\r\n                let vertices = [];\r\n                for (let j = 0; j < 3; j++)\r\n                    // @ts-ignore\r\n                    vertices.push(new _csg_lib__WEBPACK_IMPORTED_MODULE_1__.Vertex(vs[f[fm[j]]], f.vertexNormals[j], geom.faceVertexUvs[0][i][j]));\r\n                // @ts-ignore\r\n                polys.push(new _csg_lib__WEBPACK_IMPORTED_MODULE_1__.Polygon(vertices, objectIndex));\r\n            }\r\n        }\r\n        else if (geom.isBufferGeometry) {\r\n            let vertices, normals, uvs;\r\n            let posattr = geom.attributes.position;\r\n            let normalattr = geom.attributes.normal;\r\n            let uvattr = geom.attributes.uv;\r\n            let colorattr = geom.attributes.color;\r\n            let index;\r\n            if (geom.index)\r\n                index = geom.index.array;\r\n            else {\r\n                index = new Array((posattr.array.length / posattr.itemSize) | 0);\r\n                for (let i = 0; i < index.length; i++)\r\n                    index[i] = i;\r\n            }\r\n            let triCount = (index.length / 3) | 0;\r\n            polys = new Array(triCount);\r\n            for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\r\n                let vertices = new Array(3);\r\n                for (let j = 0; j < 3; j++) {\r\n                    let vi = index[i + j];\r\n                    let vp = vi * 3;\r\n                    let vt = vi * 2;\r\n                    let x = posattr.array[vp];\r\n                    let y = posattr.array[vp + 1];\r\n                    let z = posattr.array[vp + 2];\r\n                    let nx = normalattr.array[vp];\r\n                    let ny = normalattr.array[vp + 1];\r\n                    let nz = normalattr.array[vp + 2];\r\n                    let u = uvattr.array[vt];\r\n                    let v = uvattr.array[vt + 1];\r\n                    vertices[j] = new _csg_lib__WEBPACK_IMPORTED_MODULE_1__.Vertex({\r\n                        x,\r\n                        y,\r\n                        z\r\n                    }, {\r\n                        x: nx,\r\n                        y: ny,\r\n                        z: nz\r\n                    }, {\r\n                        x: u,\r\n                        y: v,\r\n                        z: 0\r\n                    }, colorattr && { x: colorattr.array[vt], y: colorattr.array[vt + 1], z: colorattr.array[vt + 2] });\r\n                }\r\n                polys[pli] = new _csg_lib__WEBPACK_IMPORTED_MODULE_1__.Polygon(vertices, objectIndex);\r\n            }\r\n        }\r\n        else\r\n            console.error('Unsupported CSG input type:' + geom.type);\r\n        return _csg_lib__WEBPACK_IMPORTED_MODULE_1__.CSG.fromPolygons(polys);\r\n    }\r\n    fromMesh(mesh, objectIndex) {\r\n        let csg = this.fromGeometry(mesh.geometry, objectIndex);\r\n        tmpm3.getNormalMatrix(mesh.matrix);\r\n        for (let i = 0; i < csg.polygons.length; i++) {\r\n            let p = csg.polygons[i];\r\n            for (let j = 0; j < p.vertices.length; j++) {\r\n                let v = p.vertices[j];\r\n                v.pos.copy(ttvv0.copy(v.pos).applyMatrix4(mesh.matrix));\r\n                v.normal.copy(ttvv0.copy(v.normal).applyMatrix3(tmpm3));\r\n            }\r\n        }\r\n        return csg;\r\n    }\r\n    toMesh(csg, toMatrix, toMaterial) {\r\n        let ps = csg.polygons;\r\n        let geom;\r\n        let g2;\r\n        //BufferGeometry path\r\n        let triCount = 0;\r\n        ps.forEach(p => (triCount += p.vertices.length - 2));\r\n        geom = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\r\n        let vertices = nbuf3(triCount * 3 * 3);\r\n        let normals = nbuf3(triCount * 3 * 3);\r\n        let uvs = nbuf2(triCount * 2 * 3);\r\n        let colors;\r\n        let grps = [];\r\n        ps.forEach(p => {\r\n            let pvs = p.vertices;\r\n            let pvlen = pvs.length;\r\n            if (p.shared !== undefined) {\r\n                // @ts-ignore\r\n                if (!grps[p.shared])\r\n                    grps[p.shared] = [];\r\n            }\r\n            if (pvlen && pvs[0].color !== undefined) {\r\n                if (!colors)\r\n                    colors = nbuf3(triCount * 3 * 3);\r\n            }\r\n            for (let j = 3; j <= pvlen; j++) {\r\n                // @ts-ignore\r\n                p.shared !== undefined && grps[p.shared].push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\r\n                vertices.write(pvs[0].pos);\r\n                vertices.write(pvs[j - 2].pos);\r\n                vertices.write(pvs[j - 1].pos);\r\n                normals.write(pvs[0].normal);\r\n                normals.write(pvs[j - 2].normal);\r\n                normals.write(pvs[j - 1].normal);\r\n                uvs.write(pvs[0].uv);\r\n                uvs.write(pvs[j - 2].uv);\r\n                uvs.write(pvs[j - 1].uv);\r\n                colors && (colors.write(pvs[0].color) || colors.write(pvs[j - 2].color) || colors.write(pvs[j - 1].color));\r\n            }\r\n        });\r\n        geom.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices.array, 3));\r\n        geom.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normals.array, 3));\r\n        geom.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs.array, 2));\r\n        colors && geom.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(colors.array, 3));\r\n        if (grps.length) {\r\n            let index = [];\r\n            let gbase = 0;\r\n            for (let gi = 0; gi < grps.length; gi++) {\r\n                // @ts-ignore\r\n                geom.addGroup(gbase, grps[gi].length, gi);\r\n                // @ts-ignore\r\n                gbase += grps[gi].length;\r\n                index = index.concat(grps[gi]);\r\n            }\r\n            geom.setIndex(index);\r\n        }\r\n        g2 = geom;\r\n        let inv = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(toMatrix).invert();\r\n        geom.applyMatrix4(inv);\r\n        geom.computeBoundingSphere();\r\n        geom.computeBoundingBox();\r\n        let m = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geom, toMaterial);\r\n        m.matrix.copy(toMatrix);\r\n        m.matrix.decompose(m.position, m.quaternion, m.scale);\r\n        m.rotation.setFromQuaternion(m.quaternion);\r\n        m.updateMatrixWorld();\r\n        m.castShadow = m.receiveShadow = true;\r\n        return m;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://ThreeCSG/./src/three-csg.ts?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/three-csg.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});